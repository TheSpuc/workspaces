package adt4September4;public class ArrayBag<T> implements BagI<T> {	private T[] array;	private static int defaultSize = 25; 	private int numberOfEntries;		/** Creates an empty bag whose initial capacity is 25. */	public ArrayBag() {		this(defaultSize); //calling the second constructor and setting the defaultSize	}		public ArrayBag(int capacity) {		@SuppressWarnings("unchecked")//Generic array is giving warnings, suppress the devil!		T[] temp = (T[])new Object[capacity]; //Javas strange way of defining a generic array		array = temp;		numberOfEntries = 0;		defaultSize = capacity;	}	public boolean add(T newEntry) {		boolean result = false;		if(!isFull()){			array[numberOfEntries] = newEntry; //because numberOfEntries is 1 based, we set the new element in of the space numberOfEntries is at.			numberOfEntries++; //count one up, so the 1 based is right			result = true;		}		return result;	}	public boolean isFull() {		return defaultSize == numberOfEntries;	}	public T[] toArray() {		@SuppressWarnings("unchecked")		T[] temp = (T[])new Object[numberOfEntries]; //simple copy method, not doing anything fancy!		for(int i=0; i<numberOfEntries; i++){			temp[i] = array[i];		}		return temp;	} 	public boolean isEmpty() {		return numberOfEntries == 0; //using that everything on the right side of the return statement i calculated first	}	public int getCurrentSize() {		return numberOfEntries;	}	public int getFrequencyOf(T anEntry) {		int result = 0;				int i = 0;		while(i<numberOfEntries){			if(array[i].equals(anEntry)){				result++; //simple count method, nothing new here			}			i++;		}		return result;	}	public boolean contains(T anEntry) {		return indexOf(anEntry) > -1; //making use of that everything on the right side of the return statement is being calculated first	}	public void clear() {		@SuppressWarnings("unchecked")//Generic array is giving warnings, suppress the devil!		T[] temp = (T[])new Object[defaultSize]; //Javas strange way of defining a generic array		array = temp;		numberOfEntries = 0;	}	public T remove() {		T result = removeEntry(numberOfEntries-1); //remove the last element, so we dont have to rearrange any items		return result;	}		public boolean remove(T anEntry) {		int index = indexOf(anEntry); //finding the index of the entry		T result = removeEntry(index); //removing the entry with the index we found.		return anEntry.equals(result); //return if it was possible to remove the entry by using if they were equal	}		/**	 * Private method for removing an entry on a specific index	 * By using the isEmpty method and remembering that numberOfEntries	 * is 1 based, we set the result as the entry at given index,	 * thereby remembering that numberOfEntries should be counted one down.	 * Afterwards we set the index to the last element in and thereby	 * making certain we don't have a hole with a null values.	 * @param index for the entry to be removed	 * @return T element that we have removed, null if the element dosn't exist.	 */	private T removeEntry(int index){		T result = null;		if(!isEmpty() && index >= 0){			result = array[index]; //result should be the element placed on array[index] 			numberOfEntries--; //one less element in the array			array[index] = array[numberOfEntries]; //taking the last element in the array and placing it in the hole we just made			array[numberOfEntries] = null; //the last element is gone, make it null		}		return result;	}		/**	 * For finding the index of a specific entry	 * @param anEntry the entry we should find	 * @return int representing the index of the given entry, if the entry dosn't exist returns -1.	 */	private int indexOf(T anEntry){		int result = -1;				boolean found = false;		int i = 0;		while(i<numberOfEntries && !found){			if(array[i].equals(anEntry)){				found = true;				result = i;			}			i++;		}		return result;	}} 