package nodes5September2;/** * A class of bags whose entries are stored in a chain of linked nodes. The bag * is never full. *  * @author Frank M. Carrano * @version 3.0 */public class DoubleLinkedBag<T> implements BagI<T> {	private Node head; // reference to first node	private Node tail;	private int numberOfEntries;	public DoubleLinkedBag() {		head = new Node();		tail = new Node();		head.next = tail;		tail.prev = head;		numberOfEntries = 0;	} // end default constructor	/**	 * Sees whether this bag is empty.	 * 	 * @return true if the bag is empty, or false if not	 */	public boolean isEmpty() {		return numberOfEntries == 0;	} // end isEmpty	/**	 * Gets the number of entries currently in this bag.	 * 	 * @return the integer number of entries currently in the bag	 */ 	public int getCurrentSize() {		return numberOfEntries;	} // end getCurrentSize	/**	 * Adds a new entry to this bag.	 * 	 * @param newEntry	 *            the object to be added as a new entry	 * @return true if the addition is successful, or false if not	 */	public boolean add(T newEntry) // OutOfMemoryError possible	{		Node refLast = tail.prev;		Node entry = new Node();		entry.data = newEntry;		entry.next = tail;		entry.prev = refLast;		tail.prev = entry;		refLast.next = entry;		numberOfEntries++;		return true;	} // end add	/**	 * Sees whether this bag is full.	 * 	 * @return false	 */	public boolean isFull() {		//TODO		return false;	} // end isFull	/**	 * Removes one unspecified entry from this bag, if possible.	 * 	 * @return either the removed entry, if the removal was successful, or null	 */	public T remove() {		T entry = null;		if(numberOfEntries>0){			Node elementToRemove = tail.prev;			entry = elementToRemove.data;			elementToRemove.data = null;			Node newLastElement = elementToRemove.prev;			tail.prev = newLastElement;			newLastElement.next = tail;			numberOfEntries--;		}		return entry; 	} // end remove	/**	 * Removes one occurrence of a given entry from this bag.	 * 	 * @param anEntry	 *            the entry to be removed	 * @return true if the removal was successful, or false otherwise	 */	public boolean remove(T anEntry) {		boolean found = false;		if(numberOfEntries>0){			Node search = head.next;			while(!found && search != tail){				if(search.data.equals(anEntry)){					search.data = null;					Node pre = search.prev;					Node post = search.next;					pre.next = post;					post.prev = pre;					numberOfEntries--;					found = true;				}else search = search.next;			}		}		return found; // STUB	} // end remove	/** Removes all entries from this bag. */	public void clear() {		while(!isEmpty()){			remove();		}	} // end clear	/**	 * Counts the number of times a given entry appears in this bag.	 * 	 * @param anEntry	 *            the entry to be counted	 * @return the number of times anEntry appears in the bag	 */	public int getFrequencyOf(T anEntry) {		int result = 0;		if(numberOfEntries>0){			Node search = head.next;			while(search != tail){				if(search.data.equals(anEntry)){					result++;				}				search = search.next;			}		}		return result;	} // end getFrequencyOf	/**	 * Tests whether this bag contains a given entry.	 * 	 * @param anEntry	 *            the entry to locate	 * @return true if the bag contains anEntry, or false otherwise	 */	public boolean contains(T anEntry) {		boolean found = false;		if(numberOfEntries>0){			Node search = head.next;			while(!found && search != tail){				if(search.data.equals(anEntry)){					found = true;				}else search = search.next;			}		}		return found; 	} // end contains	/**	 * Retrieves all entries that are in this bag.	 * 	 * @return a newly allocated array of all the entries in the bag	 */	public T[] toArray() {		// the cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] result = (T[]) new Object[numberOfEntries]; // unchecked cast		if(numberOfEntries>0){			int index = 0;			Node currentNode = head.next;			while ((index < numberOfEntries)) {				result[index] = currentNode.data;				index++;				currentNode = currentNode.next;			} // end while		}		for(T t : result){			System.out.println(t);		}		return result;	} // end toArray	private class Node {		private T data; // entry in bag		private Node next; // link to next node		private Node prev;	} // end Node} // end LinkedBag1